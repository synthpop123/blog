[{"content":" 以德国服务商 Hetzner 的 Intel Core i7-4770 拍卖机为例。\n 安装系统并组建 RAID 0 进入救援模式并一键安装系统（RAID 0），以 Debian 10 为例：\necho x | installimage -p /boot:ext3:1G,/:ext4:all -l 0 -r yes -i images/Debian-1010-buster-64-minimal.tar.gz -a -n Hz \u0026amp;\u0026amp; reboot 配置 BBR 与星大脚本 运行 AccTCP 网络优化脚本，使用 BBR 替换服务器自身的 Cubic 拥塞控制算法。\nbash \u0026lt;(curl -Ls https://git.io/AccTCP) 可以运行另一个脚本查看更详细的系统信息（包括硬盘通电时间等）：\nbash \u0026lt;(curl -Ls https://git.io/ceshi) 接下来安装星大脚本：\nbash \u0026lt;(wget -qO- https://git.io/abcde) 个人习惯一般选择安装 Deluge 1.3.15 以及 Flexget，并选择进行 system tweaks，安装完成后会展示出各个客户端的 Web UI 网址并重启。\n配置 Flexget 新建文件夹 .flexget 并进入该目录下，同时新建配置文件 config.yml。\nmkdir ~/.flexget vim ~/.flexget/config.yml 基本配置文件如下：\ntemplates:standard:free_space:path:/home/likwspace:10240seen:fields:- urlde:deluge:path:/home/likw/deluge/download/host:localhostport:58846username:likwpassword:XXXqb:qbittorrent:path:/home/likw/qbittorrent/download/host:localhostport:2017username:likwpassword:XXXtr:transmission:path:/home/likw/transmission/download/host:localhostport:9099username:likwpassword:XXXsize:content_size:min:6000max:666666strict:notasks:CHDBits:nexusphp:cookie:\u0026#39;a=xxx; b=xxx\u0026#39;discount:- free- 2xfreehr:yesrss:url:https://chdbits.co/torrentrss.php?rows=10\u0026amp;linktype=dl\u0026amp;passkey=XXXother_fields:[link]template:deUHDBits:inputs:- limit:amount:2from:rss:url:https://uhdbits.org/rss.php?action=rss\u0026amp;user=XXX\u0026amp;passkey=XXXaccept_all:yestemplate:deweb_server:port:9566web_ui:no# base_url: /flexget# schedules is disabled by default, you need to enable it or use cron to RSS试运行一次查看效果：\nflexget --test execute 安装与配置 Autoremove-torrents 中文文档，首先直接从 pip 进行安装：\npip install autoremove-torrents 接下来新建一个目录用于存放配置文件与运行日志，并进入该目录同时新建一个配置文件 config.yml：\nmkdir -p ~/.config/art/artlogs vim ~/.config/art/config.yml 基本配置文件如下：\nmy_task:client:delugehost:127.0.0.1:58846username:likwpassword:XXXstrategies:sofast:status:- Downloadingremove:(download_speed \u0026gt; 40000 and upload_speed \u0026lt; 2000) and size \u0026lt; 5solong:remove:(seeding_time \u0026gt; 2400 and upload_speed \u0026lt; 1500)delete_data:true试运行一次查看效果：\nautoremove-torrents -v -c /root/.config/art/config.yml 设置定时任务让 Flexget 和 ART 完成自动刷流任务 采用 crontab 完成定时任务：\ncrontab -e 基本配置如下：\n# 每十分钟进行一次自动删种任务 */10 * * * * /usr/local/bin/autoremove-torrents -c /root/.config/art/config.yml -l /root/.config/art/artlogs # 每两分钟获取一次 RSS 订阅并推送下载任务至 Deluge */2 * * * * /usr/local/bin/flexget --cron execute ","date":"2021-10-09T20:00:00+08:00","image":"https://blog.pkulkw.me/p/seedbox/cover_hu971c5afbd587f29bfa03084d06af259c_72306_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/seedbox/","title":"PT 自动刷流傻瓜式解决方案"},{"content":"摊还分析是一种分析一个操作序列中所执行的所有操作的平均时间分析方法。与一般的平均分析方法不同的是，它不涉及概率的分析，可以保证最坏情况下每个操作的平均性能。\n下面以带有额外 MULTIPOP 操作的栈的实例为例，分别对摊还分析中最常用的三种技术进行介绍。最后定义一种特殊的操作序列，并通过以上三种方法对其摊还代价进行分析。\n聚合分析 Aggregate Analysis 概念与定义 证明对所有 $n$，一个 $n$ 个操作的序列最坏情况下花费的总时间为 $T(n)$。因此，在最坏情况下，每个操作的平均代价（或摊还代价）为 $T(n)/n$。\n此摊还代价适用于序列中的每个操作（即使操作类型不同也是如此）。\n考虑栈操作，我们熟知的基本栈操作：\n PUSH(S, x)：将对象 x 压入栈 S 中，时间 $O(1)$； POP(S)：将栈 S 的栈顶对象弹出，并返回该对象，时间 $O(1)$。  在此基础上，增加一个新的栈操作 MULTIPOP，时间 $O(min(s, k))$。\nMULTIPOP(S, k) 1 while not STACK-EMPTY(S) and k \u0026gt; 0 2 POP(S) 3 k = k - 1 基本分析 问题：以一个由 n 个 PUSH、POP、MULTIPOP 操作的序列作用于一个空栈 S，总运行时间？\n 每个操作都可能是 MULTIPOP； 每个 MULTIPOP 的运行时间是 $O(\\min(k, s)=O(n)$； 总的运行时间的上界为 $O(n^2)$。  虽然这个分析是正确的，但我们通过单独分析每个操作的最坏情况得到的总最坏情况时间 $O(n^2)$ 并不是一个确界。\n考察出现这种情况的原因，我们发现：这 3 种操作不是平行的，而是互相影响的。换言之，只有我们每次通过 PUSH 创造 “机会” 给 POP 和 MULTIPOP，POP 和MULTIPOP 才能 “消费” 这些机会，而不存在无限制的消费。\n通过聚合分析确定摊还代价 原理：将一个对象压入栈后，我们至多将其弹出一次。\n因此，对一个非空的栈，可以执行的 POP 操作的次数(包括了 MULTIPOP 中调用 POP 的次数)最多与 PUSH 操作的次数相当，即最多 n 次。\n对任意的 n 值，任意一个由 n 个 PUSH、POP 和 MULTIPOP 组成的操作序列，最多花费 $O(n)$ 时间。故一个操作的平均时间为 $O(n)/n=O(1)$。\n核算法 Accounting Method 概念与定义 对不同操作赋予不同费用，赋予某些操作的费用可能多于或少于其实际代价。\n我们将赋予一个操作的费用称为它的摊还代价。当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构中的特定对象，存入的差额称为信用。\n注意，数据结构中存储的信用永远为非负值。否则对于到此时为止的操作序列，总摊还代价不再是总实际代价的上界。\n通过核算法确定摊还代价 $$ \\begin{array}{|c|c|c|} \\hline \\text { 操作 } \u0026amp; \\text { 实际代价 } \u0026amp; \\text { 摊还代价 } \\\\ \\hline \\text { PUSH } \u0026amp; \\mathbf{1} \u0026amp; \\mathbf{2} \\\\ \\hline \\text { POP } \u0026amp; \\mathbf{1} \u0026amp; \\mathbf{0} \\\\ \\hline \\text { MULTIPOP } \u0026amp; \\min (\\boldsymbol{k}, \\boldsymbol{s}) \u0026amp; \\mathbf{0} \\\\ \\hline \\end{array} $$\n对 PUSH 操作赋予代价 2 元：1 元支付压栈操作的实际代价，剩余的 1 元存为信用。\n当执行一个 POP/MULTIPOP 操作时，不再多缴纳费用，而是从存储的信用取出 1 元/k 元来支付其实际代价。\n势能法 Potential Method 概念与定义 并不将预付代价表示为数据结构中特定对象的信用，而是表示为 “势能”，或简称 “势”，将势能释放即可用来支付未来操作的代价。\n不需要管关心存储多少信用，而是只需要证明，每个操作积累的势能是常数的，别的操作只是消费势能就好了。\n势能法工作方式如下。我们将对一个初始数据结构 $D_{0}$ 执行 $n$ 个操作。对每个 $i=1,2, \\cdots,n$，令 $c_{i}$ 为第 i 个操作的实际代价，令 $D_{i}$ 为在数据结构 $D_{i-1}$ 上执行第 i 个操作得到的结果数据结构。\n势函数 $\\Phi$ 将每个数据结构 $D_{i}$ 映射到一个实数 $\\Phi\\left(D_{i}\\right)$，此值即为关联到数据结构 $D_{i}$ 的势。\n第 i 个操作的摊还代价 $\\hat{c}_{i}$ 用势函数 $\\Phi$ 定义为：\n$$ \\hat c_{i}=c_{i}+\\Phi(D_{i})- \\Phi(D_{i-1}) $$\n因此，每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。则 n 个操作的总摊还代价为\n$$ \\begin{aligned} \\sum_{i=1}^{n} \\widehat{c}_{i} \u0026amp;=\\sum_{i=1}^{n}\\left(c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)\\right) \\\\ \u0026amp;=\\sum_{i=1}^{n} c_{i}+\\Phi\\left(D_{n}\\right)-\\Phi\\left(D_{0}\\right) \\end{aligned} $$\n通过势能法确定摊还代价 将一个栈的势函数定义为其中的对象数量。\n 对初始空栈 $D_0$，令 $\\Phi(D_0)＝0$ 由于栈中对象数目非负，则有 $\\Phi(D_i) \\geqslant 0 = \\Phi(D_0)$  因此用 $\\Phi$ 定义的 n 个操作的总摊还代价即为实际代价的一个上界。\n下面计算不同栈操作的摊还代价。如果第 i 个操作是 PUSH 操作，此时栈中包含 s 个对象，则势差为\n$$ \\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=(s+1)-s=1 $$\n则由题意，PUSH 操作的摊还代价为\n$$ \\hat c_{i}=c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=1+1=2 $$\n假设第 i 个操作是 MULTIPOP(S, k)，将 $k^{\\prime}=\\min (k, s)$ 个对象弹出栈。对象的实际代价为 $k^{\\prime}$，势差为\n$$ \\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=-k^{\\prime} $$\n因此，MULTIPOP 的摊还代价为\n$$ \\hat c_{i}=c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=k^{\\prime}-k^{\\prime}=0 $$\n类似地，普通 $\\mathrm{POP}$ 操作的推还代价也为 0。每个操作的摊还代价都是 $O(1)$，因此，n 个操作的总摊还代价为 $O(n)$。由于我们已经论证了 $\\Phi\\left(D_{i}\\right) \\geqslant \\Phi\\left(D_{0}\\right)$，因此 n 个操作的总推还代价为总实际代价的上界，所以 n 个操作的最坏情况时间为 $O(n)$。\n实例分析 假定我们对一个数据结构执行一个由 n 个操作组成的序列，当 i 严格为 2 的幂时，第 i 个操作的代价为 i，否则代价为 1。\nExercise 1 (CLRS 17.1-3)  使用聚合分析确定每个操作的摊还代价。\n Solution: Let $n$ be arbitrary, and have the cost of operation $i$ be $c(i)$. Then we have,\n$$ \\begin{aligned} \\sum_{i = 1}^n c(i) \u0026amp; = \\sum_{i = 1}^{\\left\\lceil\\lg n\\right\\rceil} 2^i + \\sum_{i \\leqslant n \\text{ is not a power of } 2} 1 \\\\ \u0026amp; \\leqslant \\sum_{i = 1}^{\\left\\lceil\\lg n\\right\\rceil} 2^i + n \\\\ \u0026amp; = 2^{1 + \\left\\lceil\\lg n\\right\\rceil} - 1 + n \\\\ \u0026amp; \\leqslant 2n - 1 + n \\\\ \u0026amp; \\leqslant 3n \\in O(n). \\end{aligned} $$\nTo find the average, we divide by $n$, and the amortized cost per operation is $O(1)$.\nExercise 2 (CLRS 17.2-2)  使用核算法确定每个操作的摊还代价。\n Solution: Let $c_i =$ cost of $i\\th$ operation.\n$$ c_i = \\begin{cases} i \u0026amp; \\text{if $i$ is an exact power of $2$}, \\\\ 1 \u0026amp; \\text{otherwise}. \\end{cases} $$\nCharge $3$ (amortized cost $\\hat c_i$) for each operation.\n  If $i$ is not an exact power of 2, pay $1$, and store $2$ as credit.\n  If $i$ is an exact power of 2, pay $i$, using stored credit.\n  $$ \\begin{array}{cccc} \\text{Operation} \u0026amp; \\text{Cost} \u0026amp; \\text{Actual cost} \u0026amp; \\text{Credit remaining} \\\\ \\hline 1 \u0026amp; 3 \u0026amp; 1 \u0026amp; 2 \\\\ 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3 \\\\ 3 \u0026amp; 3 \u0026amp; 1 \u0026amp; 5 \\\\ 4 \u0026amp; 3 \u0026amp; 4 \u0026amp; 4 \\\\ 5 \u0026amp; 3 \u0026amp; 1 \u0026amp; 6 \\\\ 6 \u0026amp; 3 \u0026amp; 1 \u0026amp; 8 \\\\ 7 \u0026amp; 3 \u0026amp; 1 \u0026amp; 10 \\\\ 8 \u0026amp; 3 \u0026amp; 8 \u0026amp; 5 \\\\ 9 \u0026amp; 3 \u0026amp; 1 \u0026amp; 7 \\\\ 10 \u0026amp; 3 \u0026amp; 1 \u0026amp; 9 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\end{array} $$\nSince the amortized cost is $3$ per operation, $\\sum\\limits_{i = 1}^n \\hat c_i = 3n$.\nWe know from Exercise 1 that $\\sum\\limits_{i = 1}^n \\hat c_i \u0026lt; 3n$.\nThen we have\n$$\\sum_{i = 1}^n \\hat c_i \\geqslant \\sum_{i = 1}^n c_i \\Rightarrow \\text{credit} = \\text{amortized cost} - \\text{actual cost} \\geqslant 0.$$\nSince the amortized cost of each operation is $O(1)$, and the amount of credit never goes negative, the total cost of $n$ operations is $O(n)$.\nExercise 3 (CLRS 17.3-2)  使用势能法确定每个操作的摊还代价。\n Solution: Define the potential function $\\Phi(D_0) = 0$, and $\\Phi(D_i) = 2i - 2^{1 + \\lfloor \\lg i \\rfloor}$ for $i \u0026gt; 0$. For operation 1,\n$$\\begin{aligned}\\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp;= 1 + 2i - 2^{1+ \\lfloor \\lg i \\rfloor} - 0 \\\\ \u0026amp;= 1.\\end{aligned}$$\nFor operation $i(i \u0026gt; 1)$, if $i$ is not a power of 2, then\n$$ \\begin{aligned} \\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp;= 1 + 2i - 2^{1 + \\lfloor \\lg 1 \\rfloor} - (2(i - 1) - 2^{1 + \\lfloor \\lg(i - 1) \\rfloor})\\\\ \u0026amp;= 3. \\end{aligned} $$\nIf $i = 2^j$ for some $j \\in \\mathbb N$, then\n$$ \\begin{aligned} \\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp; = i + 2i - 2^{1 + j}-(2(i - 1) - 2^{1 + j - 1}) \\\\ \u0026amp;= i + 2i - 2i - 2i + 2 + i \\\\ \u0026amp;= 2. \\end{aligned} $$\nThus, the amortized cost is 3 per operation.\n","date":"2021-05-07T09:00:00+08:00","image":"https://blog.pkulkw.me/p/amortized-analysis/cover_hu5bf7d5f6bee541445b69a913d54e5097_55137_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/amortized-analysis/","title":"算法学习笔记：摊还分析 Amortized Analysis"},{"content":" \u0026ldquo;Mathematical Analysis of Algorithms\u0026rdquo; 由著名的计算机科学家 Donald Knuth 于 1971 年发表。\n 这篇文章主要引入两个具体的算法问题来展现算法效率分析的典型方法。\n Rearranging data without using auxiliary memory space. 不使用额外的存储空间的排序算法（原地排序）。 Finding the element of rank $t$ when $n$ elements are ranked by some linear ordering relation. 在线性有序表中查找特定值。  Introduction 算法分析领域的核心目标是研究如何量化分析各个不同算法的好坏，主要的两类问题如下：\n Analysis of a particular algorithm. 分析某些特定算法的基本特征。  Frequency analysis. 分析算法的各部分的执行次数情况，实际上是分析时间复杂度。 Storage analysis. 分析算法占用的内存资源情况，实际上是分析空间复杂度。   Analysis of a class of algorithms. 分析解决一类问题的所有算法，尝试找到最优的算法。  此外，本文指出第 2 类问题的两点弊端：\n 对技术性调整敏感。某些微小改变可能对最优算法的选取产生巨大的影响，因此研究往往被局限在一个有限范围内； 难以控制模型的拟合性。第 2 类问题的分析往往过于复杂，而简化模型可能与现实相悖，导致算法分析出现失误。  正因此，尽管第 1 类问题没有第 2 类问题有趣，但在实际应用中也可以发挥出巨大作用。在接下来的核心篇幅中，Knuth 便借助两个实例来具体阐述算法分析的基本思路。\n In Situ Permutation 问题提出 给定一个一维数组 $x_1,x_2,\\cdots,x_n$，以及一个函数 $p$，使得 $p(1),p(2),\\cdots,p(n)$ 是对 $1,2,\\cdots,n$ 的一个排列，同时 $x_{p(1)},x_{p(2)},\\cdots,x_{p(n)}$ 有序。附加要求如下：\n 算法的空间复杂度为 $O(1)$； 不能修改存储排列 $p(1),p(2),\\cdots,p(n)$ 的空间。  算法设计 由数学知识，我们认识到这样的事实：在任意一个排列 $p(1),p(2),\\cdots,p(n)$，我们总会存在若干个“环”，这个环形如 $p(i_1)=i_2,p(i_2)=i_3,…,p(i_k)=i_1$。\n以如下排列 $p$ 为例：\n   i 1 2 3 4 5 6 7 8 9     p(i) 8 2 7 1 6 9 3 4 5    我们可以发现这个排列中有四个“环”：\n$$ \\begin{cases} \\begin{aligned} p(1)\u0026amp;=8, p(8)=4, p(4)=1 \\\\ p(2)\u0026amp;=2 \\\\ p(3)\u0026amp;=7, p(7)=3 \\\\ p(5)\u0026amp;=6, p(6)=9, p(9)=5 \\end{aligned} \\end{cases} $$\n我们定义某一环中最小的值为这个环的头元素，那么每当我们发现了一个环的头元素 $k$，我们便将 $x_{p(k)}$ 的值填入 $x_k$ 处，将 $x_{p(p(k))}$ 的值填入 $x_{p(k)}$ 处\u0026hellip;\u0026hellip;最终将 $x_k$ 填入环的尾元素对应的位置即可。\nfor j = 1 to n # 从 p(j) 开始遍历这个环 k = p(j) # 如果 j 不是环的头元素，那么就会存在一个环上点 k \u0026lt; j while k \u0026gt; j: # --\u0026gt; a k = p(k) if k == j: # --\u0026gt; b # k 是环的头元素 y = x[j], l = p(k) while l != j: x[k] = x[l], k = l, l = p(k) x[k] = y 算法分析 由基尔霍夫定律，我们了解到所有进入某节点的电流的总和等于所有离开这节点的电流的总和，在这里，我们可以有效的衡量某部分程序的执行情况。具体地，判断 k \u0026gt; j 的总次数等于 k = p(j) 以及 k = p(k) 的执行次数之和。\n为了便于分析，在伪代码注释中标记出两个部分 a 和 b。而对于算法的正确性分析，算法的设计过程已清晰的展现，而要给出一个严谨的证明则十分麻烦，作者在此选择略繁琐的证明部分。\n极端情况 若记当前环的长度为 n，易知当 $(p(1),p(2),\\cdots,p(n))=(2,3,\u0026hellip;,n,1)$ 时即对应 a 的最坏情况，此时 $a=(n-1)+(n-2)+\\dots+0$ 取到最大值 $\\frac{1}{2}(n^2-n)$，值得注意的是，此时正好对应着 b 的最好情况。\n而相类似的，当 $(p(1),p(2),\\cdots,p(n))=(1,2,3,\u0026hellip;,n)$ 时即对应 b 的最坏情况，此时正好对应着 a 的最好情况。\n平均情况 考虑 n 个元素的全排列的 $n!$ 种可能情况是等可能的，即对应着平均情况。\n重新回顾此前的例子排列 $p$，可以这个排列的环表述为 $(1,8,4),(2),(3,7),(5,6,9)$，然而若不加限制，对其中每个环的表述方式会存在多种，难以统一，因此给予以下限制：\n 每个环从其头元素开始； 每个环的头元素递减排列。  在这样的条件下，环的表述可以固定为 $(5,6,9),(3,7),(2),(1,8,4)$。\n而此时我们发现括号的存在已无实际意义，因此可以直接去掉。那么，我们可以将每一个 $(p(1),p(2),\\cdots,p(n))$ 的排列映射为符合题意的 $(q(1),q(2),\\cdots,q(n))$。\n这时，我们可以对 b 的意义进行描述：$p$ 中的环的个数，也即 $q$ 中的 \u0026ldquo;left-to-right minima\u0026rdquo;（可以被表示为第一类斯特林数），由数学知识，记 b 的平均值为 $H_n$，b 的方差为 $H_n^{(2)}$，则有：\n$$ H_{n}=1+\\frac{1}{2}+\\cdots+\\frac{1}{n} \\quad \\text { and } \\quad H_{n}^{(2)}=1+\\frac{1}{4}+\\cdots+\\frac{1}{n^{2}} $$\n接下来我们同样可以对 a 的值进行分析。当循环变量 j = q(i) 时，$k$ 一直往后执行到 $q(i + r)$，满足 $q(i+r)\u0026lt;q(i)$ 抑或 $q(i)$ 为环的头元素，因此会从 $q(i)$ 到 $q(i + r)$ 执行运算，于是，令：\n$$ y_{ij} = \\begin{cases} 1, if\\ q(i) \u0026lt; q(k)\\ for\\ i \u0026lt; k \\leqslant j \\\\ 0, \\ otherwise \\end {cases} $$\n那么\n$$ a=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j} $$\n具体地，在以上实例中，$(q(1),\\cdots,q(9))=(5,6,9,3,7,2,1,8,4)$，此时代入公式可得 $(i,j)=(1,2),(1,3),(2,3),(4,5),(7,8),(7,9)$ 时 $y_{ij}=1$，其余情形下 $y_{ij}=0$。\n记 $y_{ij}$ 的平均值为 $\\bar{y}_{ij}$，容易发现它便是所有 $n!$ 个排列中 $y_{ij}=1$ 的排列个数，我们有：\n$$ \\begin{aligned} \\bar{a}=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\bar{y}_{i j} \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} \\\\ \u0026amp;=\\sum_{2 \\leqslant r \\leqslant n} \\frac{n+1-r}{r} \\end{aligned} $$\n记调和级数为 $H_n$，对上式进行展开：\n$$ \\bar{a}=(n+1)\\left(H_{n}-1\\right)-(n-1)=(n+1) H_{n}-2 n $$\n由数学知识我们容易证明 $H_n=\\sum\\limits_{i=1}^n\\frac{1}{i}=O(\\log n)$，因此 a 的平均执行次数为 $O(\\log n)$。\n接下来我们对 a 的方差进行求解，我们需要计算下面式子的平均值：\n$$ \\begin{aligned} \\left(\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j}\\right)^{2}=\u0026amp;\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j}^{2}+\\sum_{\\substack{1 \\leqslant i\u0026lt;j \\leqslant n \\\\ 1 \\leqslant k\u0026lt;l \\leqslant n \\\\ (i, j) \\neq(k, l)}} y_{i j} y_{k l} \\\\ =\u0026amp;\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\bar{y}_{i j} +2 \\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k\u0026lt;l \\leqslant n}\\left(y_{i j} y_{k l}+y_{i k} y_{j l}+y_{i l} y_{j k}\\right) \\\\ \u0026amp; +2 \\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k \\leqslant n}\\left(y_{i j} y_{j k}+y_{i k} y_{j k}+y_{i j} y_{i k}\\right) \\\\ =\u0026amp; \\bar{a}+2(A+B+C+D+E+F) \\end{aligned} $$\n接下来便是一系列繁杂的数学运算过程：\n$$ \\begin{array}{ll} B=\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)-2 Z, \u0026amp; C=Y-Z-2\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)+3 X \\\\ D=E=Z-X, \u0026amp; F=\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)-2 X \\end{array} $$\n其中，\n$$ \\begin{aligned} X \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} \\\\ Y \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} H_{j-i} \\\\ Z \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} H_{j-i} \\end{aligned} $$\n将 $r=j-i+1$ 代入可得：\n$$ \\begin{aligned} X\u0026amp;=(n+1) H_{n}-2 n \\\\ Y\u0026amp;=\\frac{1}{2}\\left(n^{2}+n\\right) H_{n}-\\frac{3}{4} n^{2}-\\frac{1}{4} n \\\\ Z\u0026amp;=\\frac{1}{2}(n+1)\\left(H_{n}^{2}-H_{n}^{(2)}\\right)-n H_{n}+n \\end{aligned} $$\n相对应地，\n$$ \\begin{aligned} A \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k\u0026lt;l \\leqslant n} \\frac{1}{(j-i+1)(l-k+1)} \\\\ \u0026amp;=\\sum_{\\substack{r \\geqslant 2 \\\\ s \\geqslant 2 \\\\ r+s \\leqslant n}} \\frac{1}{r s}\\left(\\begin{array}{c} n-r-s+2 \\\\ 2 \\end{array}\\right)\\\\ \u0026amp;=\\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{t}\\left(\\frac{1}{r}+\\frac{1}{t-r}\\right)\\left(\\begin{array}{c} n-t+2 \\\\ 2 \\end{array}\\right)\\\\ \u0026amp;=2 \\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{r t}\\left(\\begin{array}{c} n-t+2 \\\\ 2 \\end{array}\\right) \\\\ \u0026amp;=\\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{r t}\\left((n+2)(n+1)-t(2 n+3)+t^{2}\\right) \\\\ \u0026amp;=(n+2)(n+1) U-(2 n+3) V+W \\end{aligned} $$\n令 $r=j-i+1,s=l-k+1,t=r+s$，代入可得：\n$$ \\begin{aligned} U\u0026amp;=\\frac{1}{2}\\left(H_{n}-1\\right)^{2}-\\frac{1}{2} H_{n}^{(2)}+\\frac{1}{n} \\\\ V\u0026amp;=(n-1) H_{n-2}-2 n+4 \\\\ W\u0026amp;=\\frac{1}{2}\\left(\\left(n^{2}+n-2\\right)\\left(H_{n-2}-1\\right)-\\frac{1}{2}(n-1)(n-2)+1-3(n-3)\\right) \\end{aligned} $$\n最终带入整理可以得到：\n$$ \\sigma^{2}=2 n^{2}-(n+1)^{2} H_{n}^{(2)}-(n+1) H_{n}+4 n $$\n对 a 的方差的讨论证明了 $O(n^2)$ 的最坏情况是非常罕见的。最后再进行一些近似，可以得到如下的结论：\n$$ \\begin{aligned} a\u0026amp;=(\\min 0, \\text { ave } n \\ln n+O(n), \\max \\frac{1}{2}(n^{2}-n),\\text{dev} \\sqrt{2-\\pi^{2} / 6} n+O(\\log n)) ; \\\\ b\u0026amp;=(\\min 1, \\text { ave } \\ln n+O(1), \\max n, \\text{dev} \\sqrt{\\ln n}+O(1)) \\end{aligned} $$\n我们可以得出结论：这个算法的平均时间复杂度为 $O(n\\log n)$，在极少数情况下可能达到 $O(n^2)$。\n进一步分析 对于外循环遍历到的一个 $j$，同时搜索 $p(j), p^{-1}(j),p(p(j)),p^{-1}(p^{-1}(j)),\\cdots$，其中 $p^{-1}$ 为 $p$ 的反函数，则可以对算法进行优化。\n设最坏情况为 $f(n)$，此时整个排列只有一个长度为 n 的环，我们可以得到如下递推式：\n$$ \\begin{aligned} f(1)\u0026amp;=0 \\\\ f(n)\u0026amp;=\\max _{1 \\leqslant k\u0026lt;n}(\\min (k, n-k)+f(k)+f(n-k)) \\end{aligned} $$\n记 $\\nu(k)$ 为 $k$ 的二进制表示中 1 的个数。对于这个看起来很难下手的问题，Knuth 给出了答案：\n$$ f(n)=\\sum_{0\\leqslant k\u0026lt;n}\\nu(k) $$\n若 $a_1\u0026gt;a_2\u0026gt;\\cdots\u0026gt;a_r$，则有\n$$ f(2^{a_1}+2^{a_2}+\u0026hellip;+2^{a_r})=\\frac{1}{2}(a_12^{a_1}+(a_2+2)2^{a_2}+\u0026hellip;+(a_r+2r-2)2^{a_r}) $$\n经过以上分析，我们了解到这种解法在最坏的情况下的时间复杂度为 $O(n\\log n)$，实现了进一步的优化。\n Selecting the $t_{th}$ largest 问题提出 给定一个一维数组 $a_1,a_2,\\cdots,a_n$，在比较次数尽可能少的前提下找到数组中第 $t$ 大的值。\n算法设计 对于这种问题，一个时间复杂度为 $O(n\\log n)$ 的排序算法便可以解决，因此，我们需要考虑的是有没有时间复杂度低于 $O(n\\log n)$ 的算法。\n回忆我们已了解的算法以及刚学过的分治策略，根据快速排序的启发，我们可以采取如下思路：\n对于数组 $a_i,\\cdots,a_j$，首先调用 Partition() 方法对 $a_i$ 的位置进行移动，记移动后的位置为 k，使它左边元素都比其小、右边元素都比其大。此时我们根据 k 和 t 的大小关系，就可以分别讨论接下来的搜索是在 k 的左侧还是右侧进行，抑或是此时 k 位置的元素正好是第 k 大的元素。\nFindtthNumber(a, i, j, t): key = a[i] # Partition()的实现参考快速排序的相关原理 # Partition()返回的是分割后的数组下标 # 减去数组开头的位置得到a[k]是a[i]-a[j]里第几大的数 k = Partition(key, a, i, j) - i + 1 if k == t: return a[k] else if k \u0026lt; t: return FindtthNumber(a, k + 1, j, t - k) else: return FindtthNumber(a, i, k - 1, t) 算法分析 对子问题的限定仅与两个变量有关：数组的长度 n 以及 所要找的数的位次 t，因此我们可以记子问题为 $C_{n,t}$，假设 t 的选取完全随机，那么\n$$ \\begin{aligned} C_{1,1}\u0026amp;=0 \\\\ C_{n, t}\u0026amp;=n-1+\\frac{1}{n}\\left(A_{n, t}+B_{n, t}\\right) \\end{aligned} $$\n其中 $A_{n, t}$ 对应伪代码中 k \u0026lt; t 的情形：\n$$ A_{n, t}=C_{n-1, t-1}+C_{n-2, t-2}+\\cdots+C_{n-t+1,1} $$\n同时 $B_{n, t}$ 对应伪代码中 k \u0026gt; t 的情形：\n$$ B_{n, t}=C_{t, t}+C_{t+1, t}+\\cdots+C_{n-1, t} $$\n经过观察，我们发现\n$$ A_{n+1,t+1} = A_{n,t}+C_{n,t}\\\\ B_{n+1,t} = B_{n,t}+C_{n,t} $$\n使用差消迭代法，进行如下操作\n$$ \\begin{aligned} \u0026amp;(n+1)C_{n+1,t+1}-nC_{n,t+1}-nC_{n,t}+(n-1)C_{n-1,t} \\\\ =\u0026amp; (n+1)n - n(n-1) - n(n-1) + (n-1)(n-2) \\\\ \u0026amp;+ A_{n+1,t+1}-A_{n,t+1}-A_{n,t}+A_{n-1,t} \\\\ \u0026amp;+B_{n+1,t+1}-B_{n,t+1}-B_{n,t}+B_{n-1,t} \\\\ =\u0026amp; 2 + C_{n,t} - C_{n-1,t}+C_{n,t+1}-C_{n-1,t} \\end{aligned} $$\n进而推出\n$$ C_{n+1, t+1}-C_{n, t+1}-C_{n, t}+C_{n-1, t}=\\frac{2}{n+1} $$\n$$ \\left(C_{n+1, t+1}-C_{n, t}\\right)-\\left(C_{n, t+1}-C_{n-1, t}\\right)=\\frac{2}{n+1} $$\n由此，\n$$ \\begin{aligned} C_{n+1, t+1}-C_{n, t} \u0026amp;=\\frac{2}{n+1}+\\frac{2}{n}+\\cdots+\\frac{2}{t+2}+C_{t+1, t+1}-C_{t, t} \\\\ \u0026amp;=2\\left(H_{n+1}-H_{t+1}\\right)+2-2 /(t+1) \\end{aligned} $$\n不断进行迭代可得\n$$ C_{n, t}=2\\left((n+1) H_{n}-(n+3-t) H_{n+1-t}-(t+2) H_{t}+n+3\\right) $$\n由于调和级数 $H_n = O(\\log n)$，我们可以得出结论：无论 n 和 t 取何值，算法的平均时间复杂度为 $C_{n,t}=O(n)$。\n总结 对以上的两个算法实例进行解释分析只是作者用来解释算法分析的本质的一个途径，作者希望表明自己的以下观点：\n 算法分析对计算机科学领域十分重要，能够加深我们对计算机科学的理解； 算法分析与离散数学密切相关，许多技巧不在大学中讲授，但它们却是计算机科学家们的必修课； 算法分析正在形成科学方法，同时我们可以用一些比较通用的方法解决一系列问题； 算法分析领域还有很多问题等待着我们去解决。   参考资料：（感谢帮助！）\n “Mathematical Analysis of Algorithms” 阅读心得 [翻译] Mathematical Analysis of Algorithms   ","date":"2021-03-18T09:00:00+08:00","image":"https://blog.pkulkw.me/p/knuth-paper/cover_hu0cc505dc9d68ccc2260511a4d3bda810_44692_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/knuth-paper/","title":"论文笔记：Mathematical Analysis of Algorithms"},{"content":"很早就有自己购买域名搭建一个个人博客网站的想法了，而真正开始将这个想法付诸行动是源于 GitHub Student Developer Pack 的成功申请。\n申请 GitHub 学生开发包 GitHub 学生开发包内包含众多权益，比如 Termius 的 Premium 版、GitHub 的 Pro 版会员、name.com 以及 namecheap.com 提供的免费域名 + SSL 证书、DigitalOcean 提供的 50 刀代金券。权益实在太多了，大家可以对照官方网址逐一研究。\n GitHub 学生开发包 \n有关 GitHub 学生包具体如何申请，网上相关的教程非常多也相对比较容易，在此简单的写一下申请流程：\n 进入 GitHub 学生包 的官方页面； 点击「Get the Pack」按钮登录你的 GitHub 账号； 点击「Submit Your Information」提交信息进行申请，具体的填写可以参考下图（如果使用由学校提供的 edu 邮箱会加快审批速度）； 等待几天后收到邮件就可以享用 GitHub 学生开发包的所有权益。   GitHub 学生开发包申请示例 \n购买 DigitalOcean 云服务器 在 GitHub 学生包申请成功后我主要看了一下有关云服务器的权益，主要有 Microsoft Azure 的 100 刀额度、AWS 的 100 刀额度以及 DigitalOcean 的 50 刀额度。由于苦逼的我并没有信用卡，因此我最后选择了只需要绑定 Paypal 的 DigitalOcean。\n然而在这里我却不幸的落入了坑里，最后不得不放弃使用云服务器搭建一个 WordPress 网站的想法。\n这是由于 DigitalOcean 的邀请注册机制，新用户通过他人的邀请链接注册使用便可以获得为期两个月的 100 刀的额度，看起来不错，然而两个月相对于 GitHub 提供的一年额度实在是太短了，最主要的是每一个账户尽可以使用一次优惠同时 Paypal 只能绑定一个账户，这也导致我在通过他人的邀请链接注册后也是用不了 GitHub 学生包提供的白嫖优惠了\u0026hellip;\u0026hellip;因此，诚心告诫像我一样想要使用 DitgitalOcean 作为建站主机的穷学生一定要在浏览器的隐私页面在 官网 进行注册。\n由于我接下来在 DigitalOcean 只能够正规续费，而经过评估，DigitalOcean 所提供的使用体验以及性价比就不太好了，也因此前几天我正式的 “删库跑路”，注销了 DigitalOcean 账户。\n购买域名 + 配置 SSL 证书 我最开始是在 namecheap.com 进行选购域名，该网站可以免费提供 .me 域名一年的使用权以及有效期一年的 SSL certificate。除此之外，name.com 可以提供免费的 .studio/.ninja 等域名，在 .TECH Domains 则可以获取免费的 .tech 域名等等。\n在选择了合适的域名之后我们在网站的后台便可以管理 DNS 记录，申请开通 SSL certificate 以进行网站的下一步搭建了。\n namechaeap 网站 \n初识 WordPress 云服务器创建好之后，便可以搭建 WordPress 开发环境了。由于编译安装需要输入大量的命令，如果是配置生产环境需要耗费大量的时间，同时对 Linux 小白不太友好，因此现在比较流行的是使用 LNMP/LAMP 等一键安装包进行环境搭建。\nLNMP 的全称为 Linux + Nginx + MySql + PHP，LAMP 的全称则为 Linux + Apache + MySql + PHP，由于 Nginx 使用资源少同时支持更多并发连接，对于静态内容比较多的网站支持性不错，因此我选择了 LNMP 作为开发环境，具体的安装文档可以在 LNMP.org 查阅。\n搭建好数据库设置完毕用户名、密码等基本信息后，我们便可以到网站的后台来管理自己的博客了，首先可以选择一个好看而简单的博客主题，在这里建议一般在官方后台以及 ThemeForest 等比较正规的主题网站上下载使用而避免第三方主题携带有恶意代码等。\nWordPress 网站的后期管理相对比较简单，许多维护问题在网站后台就可以解决，如果还有遇到的问题话，Google 以及 官方文档 中基本能告诉你答案。\n告别 WordPress 拥抱 GitHub Pages 由于 DigitalOcean 的垃圾服务以及对 WordPress 的厌倦，我希望能找到一个对 Markdown 支持更好、更能使人专注于创作而不是调整页面的平台，这让我回忆起了几年前创建的 GitHub Pages。\n由于不太需要动态内容，静态网站已经可以完美的满足我的需求，对于我来说，GitHub Pages 便是一个方便的实现方案。\n而既然选择了 GitHub Pages，相应的可以选择 Hugo、Hexo、jekyll 等静态网站生成器加以实现。由于对 Hugo 的一款主题十分钟情，我便毫不犹豫地选择了 Hugo，同时，Hugo 号称是世界上生成网站最快的 framwork 倒也是蛮不错的了。\n Hugo 的官方首页 \n安装 Hugo 在 Hugo 的安装中我开始遇到了一些麻烦，与 Mac 和 Linux 相比，Windows 端的 Hugo 安装显得略微繁琐，首先在 Hugo 的 Release 页面 根据相应的版本以及平台进行下载，64 位的 Windows 电脑即选择下图中某一个即可。\n Hugo 的发行页面 \n由于部分主题需要 Hugo 的 Extended 版本才可以正常使用，因此建议一步到位直接安装 Extended 版本的 Hugo，在将压缩包解压后一定不要忘记的是将 hugo.exe 所在的文件夹添加至系统的环境变量。\n若是以上步骤都正常完成，那么可以在输入 hugo version 命令后得到正常的版本号显示。\n 检查 Hugo 版本 \n接下来便可以正式的使用 Hugo 来创建你的网站。\n初始化网站 首先选择好一个合适的存储路径，接下来便可以通过 hugo new site XXX 的命令来初始化网站。\n 初始化网站 \n接下来便可以配置自己的博客主题了，我选择的是 MemE 主题，主要是看重它的简洁大方，同时字体渲染还蛮好看。主题的官方页面如下：https://github.com/reuixiy/hugo-theme-meme\n下一步便进行主题的安装：（假设 blog 是你创建的 site 的名称）\n~ $ cd blog ~/blog $ git init ~/blog $ git submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme 同时，你也可以尝试新建文章的操作：\n~/blog $ hugo new \u0026#34;posts/hello-world.md\u0026#34; ~/blog $ hugo new \u0026#34;about/_index.md\u0026#34; Hugo 提供了一种非常便捷的预览方式，输入命令\n~/blog $ hugo server -D 便可以在浏览器键入 http://localhost:1313/ 而实现网站的实时预览。\n自定义主题 Hugo 可以提供非常强大的主题自定义的能力，根据主题所提供的配置文件，我们可以不断丰富自己的网站的功能，也可以根据自己的喜好增添许多 CSS 样式来进行美化。\n以我所使用的主题 MemE 为例，可以选择开启 KaTeX、MathJax、Mermaid 等许多功能，同时对网站的几乎所有部分都可以更改或添加自定义元素：\n MemE 主题配置节选 \n使用 Github Pages 托管网站 随后便可以在 GitHub 上建立 Repo 来托管自己的网站代码了。\n 将 config.toml 中的 baseURL 更改为你自己的自定义域名。 在 GitHub 中创建一个名称为 username.github.io 的仓库（username 替换为你自己的用户名），同时其余选项均不勾选。 在你的 Hugo 网站目录下键入命令 hugo -v 生成网站的相应文件，存储在 public 目录下。 进入 public 目录下，并按照正常的 git 命令操作： $ cd public $ git init $ git remote add origin https://github.com/XXXX/XXXX.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master  如果 git 操作正常没有报错，那么这时你便可以在你的 GitHub 仓库中看到相应的文件了。  如果你需要使用自己的自定义域名来使你的 GiHub Pages 更为精致，那么你需要先到域名管理后台添加一条 CNAME 记录：\n CNAME 记录 \n进入仓库的 Settings 页面，找到 GitHub Pages 相应设置处：\n GitHub Pages 设置 \n按照 GitHub 的提示，将自定义域名填入 Custom Domain 处，并勾选 Enforce HTTPS，等待一段时间使 DNS 记录生效后，便可以成功的访问自己的域名来进入博客了。\n若是之后对文章进行了更新，便可以使用 git push 来进行同步：\n$ cd public $ git add . $ git status $ git commit -m \u0026#34;add posts\u0026#34; $ git push 最终我的博客现在大概长下面这样：\n 网站首页预览 \n文章的大致内容大概就这么多，祝愿大家都可以顺利的建立起自己的小站。\n","date":"2021-02-08T09:00:00+08:00","image":"https://blog.pkulkw.me/p/myblog/cover_huf457792323a2069bd48065af2e6d9388_96450_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/myblog/","title":"GitHub Pages + Hugo：我的博客搭建之路"}]