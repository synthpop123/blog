[{"content":" 2020 ~ 2021 学年北京大学《影视鉴赏》课程微影评写作合集。\n 暴裂无声 Wrath of Silence (2017) 如果只能用一个词概括《暴裂无声》，我会选择“压抑”这个词。故事发生的背景选定在荒蛮的矿区，贯穿整部电影的山林、黄沙、原野无不烘托出紧张压抑的氛围。忻钰坤导演延续前作《心迷宫》的悬疑基调，以哑巴矿工张保民寻子为主线展开，同时也将徐文杰与昌万年二人的形象展现的淋漓尽致。\n一般的悬疑犯罪电影中往往充斥着大量的对白，对案情逐层剖析，而这部电影则另辟蹊径，主人公张保民自始至终未曾开口说话，更多的是借助电影语言与镜头语言来展现其满腔的怒火与不甘，推动故事情节的进一步发展。\n张保民实质上是社会中底层人物的一个写照，其“无声”也正暗示着底层人民在社会中缺失话语权的现实；相对应的，徐文杰与昌万年则分别代表着中层与上层人士。随着影片情节的发展，人物形象的逐渐丰满，不难看出导演实际上实际上希望借助电影的力量，来对“上层失善、中层失德、底层失语”这样的社会症结进行鞭挞，引发观影者的反思。\n 热情似火 Some Like It Hot (1959) 电影讲述两位乐手为了躲避黑帮的追杀而不得不男扮女装逃亡到一个女子爵士乐团的故事。从某种意义上说，这部电影可以视为好莱坞在当时逐渐成熟的工业环境下的一部极具代表性的作品，它巧妙的融合了黑帮、异装、性别转换等元素，凭借演员精湛的表演、优秀的场面调度、幽默精巧的台词被 AFI 评为百年百部喜剧佳片之首。\n在大众普遍恐同的 50 年代末，这部电影的出现可以说是“带着镣铐的舞蹈”，从性别认同的角度出发，引入大量的 Queer 元素作为喜剧性得以展现的不竭源泉。性别置换的剧情设定看似荒唐无稽，实际上极具先锋性与叛逆性，也确实如此，在五十年后的今天，它同样毫不过时。\n这部电影通过将演员置于一个不可控制的环境之中，来不断推动情节的戏剧化发展，观众的情绪也被剧情的发展所带动，这也正是其喜剧性得以突出展现的来源之一。除此之外，各类笑点的设定往往与当时社会环境相结合，观众在欣赏电影的同时也被引领着对社会现状进行反思，对社会阶级差异与普世的性别观念产生自己的思考。\n看完这样的一部优秀的喜剧作品，我想说 AFI 对其的评价实在是实至名归！\n 安全至下 Safety Last! (1923) 作为一位与卓别林齐名的喜剧大师，哈罗德·劳埃德在影片中往往扮演屡败屡战、愈挫愈勇、拿自己的生命作为赌注的小人物。在其代表作《安全至下》中，他被迫徒手攀爬12层高楼惊慌地吊在大钟的指针上的情节已成为影史留名的经典特技场景，这部电影也值得我们认真品析回味。\n陈佩斯曾说过：喜剧都有一个悲情内核。这部影片的悲情内核则是“美国梦”，在 20 年代“黄金时代”里，人们感觉到美国梦仿佛触手可得，主人公也告别小镇的未婚妻，前往大城市打拼追梦，然而人们逐渐认识到所谓的美国梦背后所代表的权力、地位、财富只不过是一场泡沫，小人物只会是上层人士走向成功的牺牲品。\n而作为一部商业片，《安全至下》突出展现了幽默风趣的一面，能给观影者带来欢声笑语。相对应地，讽刺性的表现则含蓄许多，在片尾欢快的音乐中，主人公与未婚妻在高楼顶层拥吻，似乎表现出唯有不顾生命安危方能最终实现美国梦的主题。然而，片中小人物的“成功”只是现实中一位接一位小人物的牺牲的凄凉写照，影片对当年“美国梦”的影响其背后的泡沫的描绘比其滑稽情节更值得我们反思。\n 生活多美好 It\u0026rsquo;s a Wonderful Life (1946) 作为一部治愈而温馨的励志片，《生活多美好》是那种可以为处于低谷中的人们带来无尽的感动与振奋的一剂良药。电影以回忆的方式来展开剧情，讲述的是在平安夜里主人公乔治·贝利因濒临破产而意图自杀，最终被天使所拯救的故事。\n这部电影所呈现出的是一个极具理想主义色彩的故事，在天使的帮助下，贝利看到了世界没有他的模样，从亲友的生活处境中贝利意识到了自己的存在的重要性，也感受到了“It\u0026rsquo;s a Wonderful Life”。这样的一个结局在温暖励志的同时而又出人意料，由此生发出强烈的戏剧张力。\n平凡生活着的我们，往往看似毫不起眼，没有能撼动世界的地位、财富，也因为各种限制而迫不得已地放弃我们愿倾其所有去追随的梦想。然而，贝利的经历告诉着我们 Everyone Matters，每个人都是独一无二的珍贵的存在，永远心怀善意，认真的去爱他人、爱自己。\n 将军号 The General (1926) 《将军号》是基顿最杰出的佳作之一，这部影片取材于南北战争中发生的真实事件，讲述了男主人公 Johnnie 识破北军试图劫走“将军号”、对南军进行突袭的诡计，独自深入敌营，沿途中智斗敌军，最终获得军官头衔的故事。\n影片的情节设计十分严谨，前半段中主人公深入敌营的过程与后半段其从敌营逃出的经历在结构上呈现出一种巧妙的平衡与对称。在保证影片结构严密的同时，基顿借助自己别具一格的肢体动作表演与充满现实主义的拍摄风格，使得《将军号》在保有一定的社会批判力度的同时更符合大众的银幕美学。\n惊险的追逐戏与恋人间的温情是基顿的作品中的重要元素，在《将军号》中，可以看到《警察》中陷入围捕机智逃脱的基顿，也可以看到《一周》里与妻子温馨相处的基顿。它具有着超越时代的独特魅力，直到百年后的今天，我们同样会为基顿的精彩创意而会心一笑。\n 有话好好说 Keep Cool (1997) 《有话好好说》围绕着一个有关“沟通”的故事展开，从最初时一件小小的社会矛盾出发，经过一步步的激化，最终一发不可收拾。\n影片采用了手持拍摄，摇晃的镜头带给了观众更强的代入感，能更好的表现出主角心境的变化历程，同时也为影片增添了不少荒诞感与黑色幽默。《有话好好说》并未刻意追求所谓的文艺与高雅，而是另辟蹊径，借助接地气的人物形象与台词设计，生动的还原了世纪交替之际日新月异的城市面貌与日趋浮躁的大众生活。\n荒诞源于现实，影片中所展现的荒诞色彩，说到底是为了突出现实社会中的问题而服务。人物性格的转变看似突然而不讲道理，实质上来自于群体间情绪的交互感染，不论是人还是社会，在躁动与不安的裹挟之下，走向失控都难以避免。荒诞的外壳中是人性与社会的内蕴，在为出彩的喜剧段落而喝彩的同时，其反映的社会问题更值得我们深思。\n 阳光普照 A Sun (2019)  “沒有水缸，沒有暗處，只有陽光，24小時從不間斷，明亮溫暖，陽光普照。”\n 《阳光普照》叙述了一个发生在平凡的家庭中的犯罪故事，它以诗意而写实的摄影将阿文一家历经创伤挣扎生活的过程展现得淋漓尽致。而故事的铺展娓娓道来，显得平静从容，通过沿生死、家庭伦理等话题展开的讨论，又展现出浓厚的现实主义色彩，让观影者深刻感受到影片“平静之下暗流涌动”的丰富内蕴。\n从某种意义上来讲，片名中的“阳光”即是现代社会对父权的隐喻。阿豪从来都是“别人家的孩子”，在家庭的无微不至的关怀之下成长生活，他需要去满足社会家庭的畸形期望，将自己的阳光一面完全展现，而在这种极端的压迫之下，他无法藏身。来自家庭的压抑始终笼罩心头，正因如此，阿豪做出从高楼跳下的选择即是他对父权的最终反抗。\n生活的创伤固然令已失序的家庭关系濒临破裂，然而家庭成员之间互相帮扶，同样将东方家庭所沿承的温情治愈展现得淋漓尽致。影片将家庭关系的理想性加以现实化处理呈现给观众，对社会现状层层剖析，意蕴深刻。\n 美丽心灵 A Beautiful Mind (2001) 在人物传记片的领域里，《美丽心灵》是最令我震撼的一部佳作。伟大的数学家纳什的一生跌宕起伏，他有着过人的聪颖天资，但同样在生活中历经磨难。正所谓天才与疯子之间只有一线之隔，影片所表现的纳什在两者的边缘反复游走，天才的头脑与脆弱敏感的心智似乎水火不容，但在爱人的鼓励与陪伴中，他坚持了下来，也将了不起科学研究留给了世人。\n在我看来，人物传记片的极致便是给予观影者完全沉浸到主角的人生历程之中的体验，而《美丽心灵》则很好的做到了这一点，它将纳什不为大众所知的一面展现了出来，而我们则是纳什富有传奇色彩的一生的亲历者。精神分裂给纳什的生活带来了困扰，帮助纳什努力克服疾病的是人类最纯粹的情感——爱，纳什与爱人之间互相牺牲，彼此成就，真正演绎出了“A Beautiful Mind”。\n 午夜巴黎 Midnight in Paris (2011) 生命的局限与时间长河的浩渺带给我们的对黄金时代的探索与思考从未消逝，纵然心之所向的黄金时代或许并没有那般美好无缺，但它仍在每个人的回忆之中熠熠生辉。以穿越时空为题材的影片数不胜数，《午夜巴黎》却能做到不落俗套，雨中巴黎如梦如幻的浪漫景致引人沉醉，文艺大师相继“复活”的精彩演绎更是极富创意。\n狄更斯在《双城记》中写下：“这是最好的时代，也是最坏的时代”，我们期望逃避乏味的现实，追寻心中的黄金时代，实质上是将自己的精神世界寄托于桃花源，不过只是聊以慰藉罢了。但是影片告诉我们，每个时代都有自己的辉煌和哀歌，不可能事事尽如人意，放下恋旧的心态，自己的人生又何尝不是他人羡慕的呢？\n 被解救的姜戈 Django Unchained (2012) 纵观昆汀导演的作品，《被解救的姜戈》是一部十分纯粹的西部片，影片借助诗意化的血腥镜头将昆汀的独特的暴力美学展现的淋漓尽致，是对美国黑奴历史的真实写照，可谓是相当“政治正确”的一部影片。\n暴力与野性的审美终归不是血腥场面的简单堆积，而是对暴力镜头加以诗意化的处理，弱化杀戮的残酷性，进而达到浪漫主义的表达效果。除此之外，主题的沉重并未带来过于压抑的观感，黑色幽默元素的巧妙嵌入使得影片更为诙谐。影片在展现人性与思想的解放之中得以升华，是追求自由的人本主义的呐喊。\n","date":"2021-08-08T09:00:00+08:00","image":"https://blog.pkulkw.me/p/filmreviews/cover_hu971c5afbd587f29bfa03084d06af259c_72306_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/filmreviews/","title":"《影视鉴赏》课程：微影评写作"},{"content":"摊还分析是一种分析一个操作序列中所执行的所有操作的平均时间分析方法。与一般的平均分析方法不同的是，它不涉及概率的分析，可以保证最坏情况下每个操作的平均性能。\n下面以带有额外 MULTIPOP 操作的栈的实例为例，分别对摊还分析中最常用的三种技术进行介绍。最后定义一种特殊的操作序列，并通过以上三种方法对其摊还代价进行分析。\n聚合分析 Aggregate Analysis 概念与定义 证明对所有 $n$，一个 $n$ 个操作的序列最坏情况下花费的总时间为 $T(n)$。因此，在最坏情况下，每个操作的平均代价（或摊还代价）为 $T(n)/n$。\n此摊还代价适用于序列中的每个操作（即使操作类型不同也是如此）。\n考虑栈操作，我们熟知的基本栈操作：\n PUSH(S, x)：将对象 x 压入栈 S 中，时间 $O(1)$； POP(S)：将栈 S 的栈顶对象弹出，并返回该对象，时间 $O(1)$。  在此基础上，增加一个新的栈操作 MULTIPOP，时间 $O(min(s, k))$。\nMULTIPOP(S, k) 1 while not STACK-EMPTY(S) and k \u0026gt; 0 2 POP(S) 3 k = k - 1 基本分析 问题：以一个由 n 个 PUSH、POP、MULTIPOP 操作的序列作用于一个空栈 S，总运行时间？\n 每个操作都可能是 MULTIPOP； 每个 MULTIPOP 的运行时间是 $O(\\min(k, s)=O(n)$； 总的运行时间的上界为 $O(n^2)$。  虽然这个分析是正确的，但我们通过单独分析每个操作的最坏情况得到的总最坏情况时间 $O(n^2)$ 并不是一个确界。\n考察出现这种情况的原因，我们发现：这 3 种操作不是平行的，而是互相影响的。换言之，只有我们每次通过 PUSH 创造 “机会” 给 POP 和 MULTIPOP，POP 和MULTIPOP 才能 “消费” 这些机会，而不存在无限制的消费。\n通过聚合分析确定摊还代价 原理：将一个对象压入栈后，我们至多将其弹出一次。\n因此，对一个非空的栈，可以执行的 POP 操作的次数(包括了 MULTIPOP 中调用 POP 的次数)最多与 PUSH 操作的次数相当，即最多 n 次。\n对任意的 n 值，任意一个由 n 个 PUSH、POP 和 MULTIPOP 组成的操作序列，最多花费 $O(n)$ 时间。故一个操作的平均时间为 $O(n)/n=O(1)$。\n核算法 Accounting Method 概念与定义 对不同操作赋予不同费用，赋予某些操作的费用可能多于或少于其实际代价。\n我们将赋予一个操作的费用称为它的摊还代价。当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构中的特定对象，存入的差额称为信用。\n注意，数据结构中存储的信用永远为非负值。否则对于到此时为止的操作序列，总摊还代价不再是总实际代价的上界。\n通过核算法确定摊还代价 $$ \\begin{array}{|c|c|c|} \\hline \\text { 操作 } \u0026amp; \\text { 实际代价 } \u0026amp; \\text { 摊还代价 } \\\\ \\hline \\text { PUSH } \u0026amp; \\mathbf{1} \u0026amp; \\mathbf{2} \\\\ \\hline \\text { POP } \u0026amp; \\mathbf{1} \u0026amp; \\mathbf{0} \\\\ \\hline \\text { MULTIPOP } \u0026amp; \\min (\\boldsymbol{k}, \\boldsymbol{s}) \u0026amp; \\mathbf{0} \\\\ \\hline \\end{array} $$\n对 PUSH 操作赋予代价 2 元：1 元支付压栈操作的实际代价，剩余的 1 元存为信用。\n当执行一个 POP/MULTIPOP 操作时，不再多缴纳费用，而是从存储的信用取出 1 元/k 元来支付其实际代价。\n势能法 Potential Method 概念与定义 并不将预付代价表示为数据结构中特定对象的信用，而是表示为 “势能”，或简称 “势”，将势能释放即可用来支付未来操作的代价。\n不需要管关心存储多少信用，而是只需要证明，每个操作积累的势能是常数的，别的操作只是消费势能就好了。\n势能法工作方式如下。我们将对一个初始数据结构 $D_{0}$ 执行 $n$ 个操作。对每个 $i=1,2, \\cdots,n$，令 $c_{i}$ 为第 i 个操作的实际代价，令 $D_{i}$ 为在数据结构 $D_{i-1}$ 上执行第 i 个操作得到的结果数据结构。\n势函数 $\\Phi$ 将每个数据结构 $D_{i}$ 映射到一个实数 $\\Phi\\left(D_{i}\\right)$，此值即为关联到数据结构 $D_{i}$ 的势。\n第 i 个操作的摊还代价 $\\hat{c}_{i}$ 用势函数 $\\Phi$ 定义为：\n$$ \\hat c_{i}=c_{i}+\\Phi(D_{i})- \\Phi(D_{i-1}) $$\n因此，每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。则 n 个操作的总摊还代价为\n$$ \\begin{aligned} \\sum_{i=1}^{n} \\widehat{c}_{i} \u0026amp;=\\sum_{i=1}^{n}\\left(c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)\\right) \\\\ \u0026amp;=\\sum_{i=1}^{n} c_{i}+\\Phi\\left(D_{n}\\right)-\\Phi\\left(D_{0}\\right) \\end{aligned} $$\n通过势能法确定摊还代价 将一个栈的势函数定义为其中的对象数量。\n 对初始空栈 $D_0$，令 $\\Phi(D_0)＝0$ 由于栈中对象数目非负，则有 $\\Phi(D_i) \\geqslant 0 = \\Phi(D_0)$  因此用 $\\Phi$ 定义的 n 个操作的总摊还代价即为实际代价的一个上界。\n下面计算不同栈操作的摊还代价。如果第 i 个操作是 PUSH 操作，此时栈中包含 s 个对象，则势差为\n$$ \\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=(s+1)-s=1 $$\n则由题意，PUSH 操作的摊还代价为\n$$ \\hat c_{i}=c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=1+1=2 $$\n假设第 i 个操作是 MULTIPOP(S, k)，将 $k^{\\prime}=\\min (k, s)$ 个对象弹出栈。对象的实际代价为 $k^{\\prime}$，势差为\n$$ \\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=-k^{\\prime} $$\n因此，MULTIPOP 的摊还代价为\n$$ \\hat c_{i}=c_{i}+\\Phi\\left(D_{i}\\right)-\\Phi\\left(D_{i-1}\\right)=k^{\\prime}-k^{\\prime}=0 $$\n类似地，普通 $\\mathrm{POP}$ 操作的推还代价也为 0。每个操作的摊还代价都是 $O(1)$，因此，n 个操作的总摊还代价为 $O(n)$。由于我们已经论证了 $\\Phi\\left(D_{i}\\right) \\geqslant \\Phi\\left(D_{0}\\right)$，因此 n 个操作的总推还代价为总实际代价的上界，所以 n 个操作的最坏情况时间为 $O(n)$。\n实例分析 假定我们对一个数据结构执行一个由 n 个操作组成的序列，当 i 严格为 2 的幂时，第 i 个操作的代价为 i，否则代价为 1。\nExercise 1 (CLRS 17.1-3)  使用聚合分析确定每个操作的摊还代价。\n Solution: Let $n$ be arbitrary, and have the cost of operation $i$ be $c(i)$. Then we have,\n$$ \\begin{aligned} \\sum_{i = 1}^n c(i) \u0026amp; = \\sum_{i = 1}^{\\left\\lceil\\lg n\\right\\rceil} 2^i + \\sum_{i \\leqslant n \\text{ is not a power of } 2} 1 \\\\ \u0026amp; \\leqslant \\sum_{i = 1}^{\\left\\lceil\\lg n\\right\\rceil} 2^i + n \\\\ \u0026amp; = 2^{1 + \\left\\lceil\\lg n\\right\\rceil} - 1 + n \\\\ \u0026amp; \\leqslant 2n - 1 + n \\\\ \u0026amp; \\leqslant 3n \\in O(n). \\end{aligned} $$\nTo find the average, we divide by $n$, and the amortized cost per operation is $O(1)$.\nExercise 2 (CLRS 17.2-2)  使用核算法确定每个操作的摊还代价。\n Solution: Let $c_i =$ cost of $i\\th$ operation.\n$$ c_i = \\begin{cases} i \u0026amp; \\text{if $i$ is an exact power of $2$}, \\\\ 1 \u0026amp; \\text{otherwise}. \\end{cases} $$\nCharge $3$ (amortized cost $\\hat c_i$) for each operation.\n  If $i$ is not an exact power of 2, pay $1$, and store $2$ as credit.\n  If $i$ is an exact power of 2, pay $i$, using stored credit.\n  $$ \\begin{array}{cccc} \\text{Operation} \u0026amp; \\text{Cost} \u0026amp; \\text{Actual cost} \u0026amp; \\text{Credit remaining} \\\\ \\hline 1 \u0026amp; 3 \u0026amp; 1 \u0026amp; 2 \\\\ 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3 \\\\ 3 \u0026amp; 3 \u0026amp; 1 \u0026amp; 5 \\\\ 4 \u0026amp; 3 \u0026amp; 4 \u0026amp; 4 \\\\ 5 \u0026amp; 3 \u0026amp; 1 \u0026amp; 6 \\\\ 6 \u0026amp; 3 \u0026amp; 1 \u0026amp; 8 \\\\ 7 \u0026amp; 3 \u0026amp; 1 \u0026amp; 10 \\\\ 8 \u0026amp; 3 \u0026amp; 8 \u0026amp; 5 \\\\ 9 \u0026amp; 3 \u0026amp; 1 \u0026amp; 7 \\\\ 10 \u0026amp; 3 \u0026amp; 1 \u0026amp; 9 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\end{array} $$\nSince the amortized cost is $3$ per operation, $\\sum\\limits_{i = 1}^n \\hat c_i = 3n$.\nWe know from Exercise 1 that $\\sum\\limits_{i = 1}^n \\hat c_i \u0026lt; 3n$.\nThen we have\n$$\\sum_{i = 1}^n \\hat c_i \\geqslant \\sum_{i = 1}^n c_i \\Rightarrow \\text{credit} = \\text{amortized cost} - \\text{actual cost} \\geqslant 0.$$\nSince the amortized cost of each operation is $O(1)$, and the amount of credit never goes negative, the total cost of $n$ operations is $O(n)$.\nExercise 3 (CLRS 17.3-2)  使用势能法确定每个操作的摊还代价。\n Solution: Define the potential function $\\Phi(D_0) = 0$, and $\\Phi(D_i) = 2i - 2^{1 + \\lfloor \\lg i \\rfloor}$ for $i \u0026gt; 0$. For operation 1,\n$$\\begin{aligned}\\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp;= 1 + 2i - 2^{1+ \\lfloor \\lg i \\rfloor} - 0 \\\\ \u0026amp;= 1.\\end{aligned}$$\nFor operation $i(i \u0026gt; 1)$, if $i$ is not a power of 2, then\n$$ \\begin{aligned} \\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp;= 1 + 2i - 2^{1 + \\lfloor \\lg 1 \\rfloor} - (2(i - 1) - 2^{1 + \\lfloor \\lg(i - 1) \\rfloor})\\\\ \u0026amp;= 3. \\end{aligned} $$\nIf $i = 2^j$ for some $j \\in \\mathbb N$, then\n$$ \\begin{aligned} \\hat c_i \u0026amp;= c_i + \\Phi(D_i) - \\Phi(D_{i - 1}) \\\\ \u0026amp; = i + 2i - 2^{1 + j}-(2(i - 1) - 2^{1 + j - 1}) \\\\ \u0026amp;= i + 2i - 2i - 2i + 2 + i \\\\ \u0026amp;= 2. \\end{aligned} $$\nThus, the amortized cost is 3 per operation.\n","date":"2021-05-07T09:00:00+08:00","image":"https://blog.pkulkw.me/p/amortized-analysis/cover_hu5bf7d5f6bee541445b69a913d54e5097_55137_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/amortized-analysis/","title":"算法学习笔记：摊还分析 Amortized Analysis"},{"content":" \u0026ldquo;Mathematical Analysis of Algorithms\u0026rdquo; 由著名的计算机科学家 Donald Knuth 于 1971 年发表。\n 这篇文章主要引入两个具体的算法问题来展现算法效率分析的典型方法。\n Rearranging data without using auxiliary memory space. 不使用额外的存储空间的排序算法（原地排序）。 Finding the element of rank $t$ when $n$ elements are ranked by some linear ordering relation. 在线性有序表中查找特定值。  Introduction 算法分析领域的核心目标是研究如何量化分析各个不同算法的好坏，主要的两类问题如下：\n Analysis of a particular algorithm. 分析某些特定算法的基本特征。  Frequency analysis. 分析算法的各部分的执行次数情况，实际上是分析时间复杂度。 Storage analysis. 分析算法占用的内存资源情况，实际上是分析空间复杂度。   Analysis of a class of algorithms. 分析解决一类问题的所有算法，尝试找到最优的算法。  此外，本文指出第 2 类问题的两点弊端：\n 对技术性调整敏感。某些微小改变可能对最优算法的选取产生巨大的影响，因此研究往往被局限在一个有限范围内； 难以控制模型的拟合性。第 2 类问题的分析往往过于复杂，而简化模型可能与现实相悖，导致算法分析出现失误。  正因此，尽管第 1 类问题没有第 2 类问题有趣，但在实际应用中也可以发挥出巨大作用。在接下来的核心篇幅中，Knuth 便借助两个实例来具体阐述算法分析的基本思路。\n In Situ Permutation 问题提出 给定一个一维数组 $x_1,x_2,\\cdots,x_n$，以及一个函数 $p$，使得 $p(1),p(2),\\cdots,p(n)$ 是对 $1,2,\\cdots,n$ 的一个排列，同时 $x_{p(1)},x_{p(2)},\\cdots,x_{p(n)}$ 有序。附加要求如下：\n 算法的空间复杂度为 $O(1)$； 不能修改存储排列 $p(1),p(2),\\cdots,p(n)$ 的空间。  算法设计 由数学知识，我们认识到这样的事实：在任意一个排列 $p(1),p(2),\\cdots,p(n)$，我们总会存在若干个“环”，这个环形如 $p(i_1)=i_2,p(i_2)=i_3,…,p(i_k)=i_1$。\n以如下排列 $p$ 为例：\n   i 1 2 3 4 5 6 7 8 9     p(i) 8 2 7 1 6 9 3 4 5    我们可以发现这个排列中有四个“环”：\n$$ \\begin{cases} \\begin{aligned} p(1)\u0026amp;=8, p(8)=4, p(4)=1 \\\\ p(2)\u0026amp;=2 \\\\ p(3)\u0026amp;=7, p(7)=3 \\\\ p(5)\u0026amp;=6, p(6)=9, p(9)=5 \\end{aligned} \\end{cases} $$\n我们定义某一环中最小的值为这个环的头元素，那么每当我们发现了一个环的头元素 $k$，我们便将 $x_{p(k)}$ 的值填入 $x_k$ 处，将 $x_{p(p(k))}$ 的值填入 $x_{p(k)}$ 处\u0026hellip;\u0026hellip;最终将 $x_k$ 填入环的尾元素对应的位置即可。\nfor j = 1 to n # 从 p(j) 开始遍历这个环 k = p(j) # 如果 j 不是环的头元素，那么就会存在一个环上点 k \u0026lt; j while k \u0026gt; j: # --\u0026gt; a k = p(k) if k == j: # --\u0026gt; b # k 是环的头元素 y = x[j], l = p(k) while l != j: x[k] = x[l], k = l, l = p(k) x[k] = y 算法分析 由基尔霍夫定律，我们了解到所有进入某节点的电流的总和等于所有离开这节点的电流的总和，在这里，我们可以有效的衡量某部分程序的执行情况。具体地，判断 k \u0026gt; j 的总次数等于 k = p(j) 以及 k = p(k) 的执行次数之和。\n为了便于分析，在伪代码注释中标记出两个部分 a 和 b。而对于算法的正确性分析，算法的设计过程已清晰的展现，而要给出一个严谨的证明则十分麻烦，作者在此选择略繁琐的证明部分。\n极端情况 若记当前环的长度为 n，易知当 $(p(1),p(2),\\cdots,p(n))=(2,3,\u0026hellip;,n,1)$ 时即对应 a 的最坏情况，此时 $a=(n-1)+(n-2)+\\dots+0$ 取到最大值 $\\frac{1}{2}(n^2-n)$，值得注意的是，此时正好对应着 b 的最好情况。\n而相类似的，当 $(p(1),p(2),\\cdots,p(n))=(1,2,3,\u0026hellip;,n)$ 时即对应 b 的最坏情况，此时正好对应着 a 的最好情况。\n平均情况 考虑 n 个元素的全排列的 $n!$ 种可能情况是等可能的，即对应着平均情况。\n重新回顾此前的例子排列 $p$，可以这个排列的环表述为 $(1,8,4),(2),(3,7),(5,6,9)$，然而若不加限制，对其中每个环的表述方式会存在多种，难以统一，因此给予以下限制：\n 每个环从其头元素开始； 每个环的头元素递减排列。  在这样的条件下，环的表述可以固定为 $(5,6,9),(3,7),(2),(1,8,4)$。\n而此时我们发现括号的存在已无实际意义，因此可以直接去掉。那么，我们可以将每一个 $(p(1),p(2),\\cdots,p(n))$ 的排列映射为符合题意的 $(q(1),q(2),\\cdots,q(n))$。\n这时，我们可以对 b 的意义进行描述：$p$ 中的环的个数，也即 $q$ 中的 \u0026ldquo;left-to-right minima\u0026rdquo;（可以被表示为第一类斯特林数），由数学知识，记 b 的平均值为 $H_n$，b 的方差为 $H_n^{(2)}$，则有：\n$$ H_{n}=1+\\frac{1}{2}+\\cdots+\\frac{1}{n} \\quad \\text { and } \\quad H_{n}^{(2)}=1+\\frac{1}{4}+\\cdots+\\frac{1}{n^{2}} $$\n接下来我们同样可以对 a 的值进行分析。当循环变量 j = q(i) 时，$k$ 一直往后执行到 $q(i + r)$，满足 $q(i+r)\u0026lt;q(i)$ 抑或 $q(i)$ 为环的头元素，因此会从 $q(i)$ 到 $q(i + r)$ 执行运算，于是，令：\n$$ y_{ij} = \\begin{cases} 1, if\\ q(i) \u0026lt; q(k)\\ for\\ i \u0026lt; k \\leqslant j \\\\ 0, \\ otherwise \\end {cases} $$\n那么\n$$ a=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j} $$\n具体地，在以上实例中，$(q(1),\\cdots,q(9))=(5,6,9,3,7,2,1,8,4)$，此时代入公式可得 $(i,j)=(1,2),(1,3),(2,3),(4,5),(7,8),(7,9)$ 时 $y_{ij}=1$，其余情形下 $y_{ij}=0$。\n记 $y_{ij}$ 的平均值为 $\\bar{y}_{ij}$，容易发现它便是所有 $n!$ 个排列中 $y_{ij}=1$ 的排列个数，我们有：\n$$ \\begin{aligned} \\bar{a}=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\bar{y}_{i j} \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} \\\\ \u0026amp;=\\sum_{2 \\leqslant r \\leqslant n} \\frac{n+1-r}{r} \\end{aligned} $$\n记调和级数为 $H_n$，对上式进行展开：\n$$ \\bar{a}=(n+1)\\left(H_{n}-1\\right)-(n-1)=(n+1) H_{n}-2 n $$\n由数学知识我们容易证明 $H_n=\\sum\\limits_{i=1}^n\\frac{1}{i}=O(\\log n)$，因此 a 的平均执行次数为 $O(\\log n)$。\n接下来我们对 a 的方差进行求解，我们需要计算下面式子的平均值：\n$$ \\begin{aligned} \\left(\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j}\\right)^{2}=\u0026amp;\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} y_{i j}^{2}+\\sum_{\\substack{1 \\leqslant i\u0026lt;j \\leqslant n \\\\ 1 \\leqslant k\u0026lt;l \\leqslant n \\\\ (i, j) \\neq(k, l)}} y_{i j} y_{k l} \\\\ =\u0026amp;\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\bar{y}_{i j} +2 \\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k\u0026lt;l \\leqslant n}\\left(y_{i j} y_{k l}+y_{i k} y_{j l}+y_{i l} y_{j k}\\right) \\\\ \u0026amp; +2 \\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k \\leqslant n}\\left(y_{i j} y_{j k}+y_{i k} y_{j k}+y_{i j} y_{i k}\\right) \\\\ =\u0026amp; \\bar{a}+2(A+B+C+D+E+F) \\end{aligned} $$\n接下来便是一系列繁杂的数学运算过程：\n$$ \\begin{array}{ll} B=\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)-2 Z, \u0026amp; C=Y-Z-2\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)+3 X \\\\ D=E=Z-X, \u0026amp; F=\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)-2 X \\end{array} $$\n其中，\n$$ \\begin{aligned} X \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} \\\\ Y \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} H_{j-i} \\\\ Z \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j \\leqslant n} \\frac{1}{j-i+1} H_{j-i} \\end{aligned} $$\n将 $r=j-i+1$ 代入可得：\n$$ \\begin{aligned} X\u0026amp;=(n+1) H_{n}-2 n \\\\ Y\u0026amp;=\\frac{1}{2}\\left(n^{2}+n\\right) H_{n}-\\frac{3}{4} n^{2}-\\frac{1}{4} n \\\\ Z\u0026amp;=\\frac{1}{2}(n+1)\\left(H_{n}^{2}-H_{n}^{(2)}\\right)-n H_{n}+n \\end{aligned} $$\n相对应地，\n$$ \\begin{aligned} A \u0026amp;=\\sum_{1 \\leqslant i\u0026lt;j\u0026lt;k\u0026lt;l \\leqslant n} \\frac{1}{(j-i+1)(l-k+1)} \\\\ \u0026amp;=\\sum_{\\substack{r \\geqslant 2 \\\\ s \\geqslant 2 \\\\ r+s \\leqslant n}} \\frac{1}{r s}\\left(\\begin{array}{c} n-r-s+2 \\\\ 2 \\end{array}\\right)\\\\ \u0026amp;=\\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{t}\\left(\\frac{1}{r}+\\frac{1}{t-r}\\right)\\left(\\begin{array}{c} n-t+2 \\\\ 2 \\end{array}\\right)\\\\ \u0026amp;=2 \\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{r t}\\left(\\begin{array}{c} n-t+2 \\\\ 2 \\end{array}\\right) \\\\ \u0026amp;=\\sum_{\\substack{2 \\leqslant r \\leqslant t-2 \\\\ 4 \\leqslant t \\leqslant n}} \\frac{1}{r t}\\left((n+2)(n+1)-t(2 n+3)+t^{2}\\right) \\\\ \u0026amp;=(n+2)(n+1) U-(2 n+3) V+W \\end{aligned} $$\n令 $r=j-i+1,s=l-k+1,t=r+s$，代入可得：\n$$ \\begin{aligned} U\u0026amp;=\\frac{1}{2}\\left(H_{n}-1\\right)^{2}-\\frac{1}{2} H_{n}^{(2)}+\\frac{1}{n} \\\\ V\u0026amp;=(n-1) H_{n-2}-2 n+4 \\\\ W\u0026amp;=\\frac{1}{2}\\left(\\left(n^{2}+n-2\\right)\\left(H_{n-2}-1\\right)-\\frac{1}{2}(n-1)(n-2)+1-3(n-3)\\right) \\end{aligned} $$\n最终带入整理可以得到：\n$$ \\sigma^{2}=2 n^{2}-(n+1)^{2} H_{n}^{(2)}-(n+1) H_{n}+4 n $$\n对 a 的方差的讨论证明了 $O(n^2)$ 的最坏情况是非常罕见的。最后再进行一些近似，可以得到如下的结论：\n$$ \\begin{aligned} a\u0026amp;=(\\min 0, \\text { ave } n \\ln n+O(n), \\max \\frac{1}{2}(n^{2}-n),\\text{dev} \\sqrt{2-\\pi^{2} / 6} n+O(\\log n)) ; \\\\ b\u0026amp;=(\\min 1, \\text { ave } \\ln n+O(1), \\max n, \\text{dev} \\sqrt{\\ln n}+O(1)) \\end{aligned} $$\n我们可以得出结论：这个算法的平均时间复杂度为 $O(n\\log n)$，在极少数情况下可能达到 $O(n^2)$。\n进一步分析 对于外循环遍历到的一个 $j$，同时搜索 $p(j), p^{-1}(j),p(p(j)),p^{-1}(p^{-1}(j)),\\cdots$，其中 $p^{-1}$ 为 $p$ 的反函数，则可以对算法进行优化。\n设最坏情况为 $f(n)$，此时整个排列只有一个长度为 n 的环，我们可以得到如下递推式：\n$$ \\begin{aligned} f(1)\u0026amp;=0 \\\\ f(n)\u0026amp;=\\max _{1 \\leqslant k\u0026lt;n}(\\min (k, n-k)+f(k)+f(n-k)) \\end{aligned} $$\n记 $\\nu(k)$ 为 $k$ 的二进制表示中 1 的个数。对于这个看起来很难下手的问题，Knuth 给出了答案：\n$$ f(n)=\\sum_{0\\leqslant k\u0026lt;n}\\nu(k) $$\n若 $a_1\u0026gt;a_2\u0026gt;\\cdots\u0026gt;a_r$，则有\n$$ f(2^{a_1}+2^{a_2}+\u0026hellip;+2^{a_r})=\\frac{1}{2}(a_12^{a_1}+(a_2+2)2^{a_2}+\u0026hellip;+(a_r+2r-2)2^{a_r}) $$\n经过以上分析，我们了解到这种解法在最坏的情况下的时间复杂度为 $O(n\\log n)$，实现了进一步的优化。\n Selecting the $t_{th}$ largest 问题提出 给定一个一维数组 $a_1,a_2,\\cdots,a_n$，在比较次数尽可能少的前提下找到数组中第 $t$ 大的值。\n算法设计 对于这种问题，一个时间复杂度为 $O(n\\log n)$ 的排序算法便可以解决，因此，我们需要考虑的是有没有时间复杂度低于 $O(n\\log n)$ 的算法。\n回忆我们已了解的算法以及刚学过的分治策略，根据快速排序的启发，我们可以采取如下思路：\n对于数组 $a_i,\\cdots,a_j$，首先调用 Partition() 方法对 $a_i$ 的位置进行移动，记移动后的位置为 k，使它左边元素都比其小、右边元素都比其大。此时我们根据 k 和 t 的大小关系，就可以分别讨论接下来的搜索是在 k 的左侧还是右侧进行，抑或是此时 k 位置的元素正好是第 k 大的元素。\nFindtthNumber(a, i, j, t): key = a[i] # Partition()的实现参考快速排序的相关原理 # Partition()返回的是分割后的数组下标 # 减去数组开头的位置得到a[k]是a[i]-a[j]里第几大的数 k = Partition(key, a, i, j) - i + 1 if k == t: return a[k] else if k \u0026lt; t: return FindtthNumber(a, k + 1, j, t - k) else: return FindtthNumber(a, i, k - 1, t) 算法分析 对子问题的限定仅与两个变量有关：数组的长度 n 以及 所要找的数的位次 t，因此我们可以记子问题为 $C_{n,t}$，假设 t 的选取完全随机，那么\n$$ \\begin{aligned} C_{1,1}\u0026amp;=0 \\\\ C_{n, t}\u0026amp;=n-1+\\frac{1}{n}\\left(A_{n, t}+B_{n, t}\\right) \\end{aligned} $$\n其中 $A_{n, t}$ 对应伪代码中 k \u0026lt; t 的情形：\n$$ A_{n, t}=C_{n-1, t-1}+C_{n-2, t-2}+\\cdots+C_{n-t+1,1} $$\n同时 $B_{n, t}$ 对应伪代码中 k \u0026gt; t 的情形：\n$$ B_{n, t}=C_{t, t}+C_{t+1, t}+\\cdots+C_{n-1, t} $$\n经过观察，我们发现\n$$ A_{n+1,t+1} = A_{n,t}+C_{n,t}\\\\ B_{n+1,t} = B_{n,t}+C_{n,t} $$\n使用差消迭代法，进行如下操作\n$$ \\begin{aligned} \u0026amp;(n+1)C_{n+1,t+1}-nC_{n,t+1}-nC_{n,t}+(n-1)C_{n-1,t} \\\\ =\u0026amp; (n+1)n - n(n-1) - n(n-1) + (n-1)(n-2) \\\\ \u0026amp;+ A_{n+1,t+1}-A_{n,t+1}-A_{n,t}+A_{n-1,t} \\\\ \u0026amp;+B_{n+1,t+1}-B_{n,t+1}-B_{n,t}+B_{n-1,t} \\\\ =\u0026amp; 2 + C_{n,t} - C_{n-1,t}+C_{n,t+1}-C_{n-1,t} \\end{aligned} $$\n进而推出\n$$ C_{n+1, t+1}-C_{n, t+1}-C_{n, t}+C_{n-1, t}=\\frac{2}{n+1} $$\n$$ \\left(C_{n+1, t+1}-C_{n, t}\\right)-\\left(C_{n, t+1}-C_{n-1, t}\\right)=\\frac{2}{n+1} $$\n由此，\n$$ \\begin{aligned} C_{n+1, t+1}-C_{n, t} \u0026amp;=\\frac{2}{n+1}+\\frac{2}{n}+\\cdots+\\frac{2}{t+2}+C_{t+1, t+1}-C_{t, t} \\\\ \u0026amp;=2\\left(H_{n+1}-H_{t+1}\\right)+2-2 /(t+1) \\end{aligned} $$\n不断进行迭代可得\n$$ C_{n, t}=2\\left((n+1) H_{n}-(n+3-t) H_{n+1-t}-(t+2) H_{t}+n+3\\right) $$\n由于调和级数 $H_n = O(\\log n)$，我们可以得出结论：无论 n 和 t 取何值，算法的平均时间复杂度为 $C_{n,t}=O(n)$。\n总结 对以上的两个算法实例进行解释分析只是作者用来解释算法分析的本质的一个途径，作者希望表明自己的以下观点：\n 算法分析对计算机科学领域十分重要，能够加深我们对计算机科学的理解； 算法分析与离散数学密切相关，许多技巧不在大学中讲授，但它们却是计算机科学家们的必修课； 算法分析正在形成科学方法，同时我们可以用一些比较通用的方法解决一系列问题； 算法分析领域还有很多问题等待着我们去解决。   参考资料：（感谢帮助！）\n “Mathematical Analysis of Algorithms” 阅读心得 [翻译] Mathematical Analysis of Algorithms   ","date":"2021-03-18T09:00:00+08:00","image":"https://blog.pkulkw.me/p/knuth-paper/cover_hu0cc505dc9d68ccc2260511a4d3bda810_44692_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/knuth-paper/","title":"论文笔记：Mathematical Analysis of Algorithms"},{"content":"很早就有自己购买域名搭建一个个人博客网站的想法了，而真正开始将这个想法付诸行动是源于 GitHub Student Developer Pack 的成功申请。\n申请 GitHub 学生开发包 GitHub 学生开发包内包含众多权益，比如 Termius 的 Premium 版、GitHub 的 Pro 版会员、name.com 以及 namecheap.com 提供的免费域名 + SSL 证书、DigitalOcean 提供的 50 刀代金券。权益实在太多了，大家可以对照官方网址逐一研究。\n GitHub 学生开发包 \n有关 GitHub 学生包具体如何申请，网上相关的教程非常多也相对比较容易，在此简单的写一下申请流程：\n 进入 GitHub 学生包 的官方页面； 点击「Get the Pack」按钮登录你的 GitHub 账号； 点击「Submit Your Information」提交信息进行申请，具体的填写可以参考下图（如果使用由学校提供的 edu 邮箱会加快审批速度）； 等待几天后收到邮件就可以享用 GitHub 学生开发包的所有权益。   GitHub 学生开发包申请示例 \n购买 DigitalOcean 云服务器 在 GitHub 学生包申请成功后我主要看了一下有关云服务器的权益，主要有 Microsoft Azure 的 100 刀额度、AWS 的 100 刀额度以及 DigitalOcean 的 50 刀额度。由于苦逼的我并没有信用卡，因此我最后选择了只需要绑定 Paypal 的 DigitalOcean。\n然而在这里我却不幸的落入了坑里，最后不得不放弃使用云服务器搭建一个 WordPress 网站的想法。\n这是由于 DigitalOcean 的邀请注册机制，新用户通过他人的邀请链接注册使用便可以获得为期两个月的 100 刀的额度，看起来不错，然而两个月相对于 GitHub 提供的一年额度实在是太短了，最主要的是每一个账户尽可以使用一次优惠同时 Paypal 只能绑定一个账户，这也导致我在通过他人的邀请链接注册后也是用不了 GitHub 学生包提供的白嫖优惠了\u0026hellip;\u0026hellip;因此，诚心告诫像我一样想要使用 DitgitalOcean 作为建站主机的穷学生一定要在浏览器的隐私页面在 官网 进行注册。\n由于我接下来在 DigitalOcean 只能够正规续费，而经过评估，DigitalOcean 所提供的使用体验以及性价比就不太好了，也因此前几天我正式的 “删库跑路”，注销了 DigitalOcean 账户。\n购买域名 + 配置 SSL 证书 我最开始是在 namecheap.com 进行选购域名，该网站可以免费提供 .me 域名一年的使用权以及有效期一年的 SSL certificate。除此之外，name.com 可以提供免费的 .studio/.ninja 等域名，在 .TECH Domains 则可以获取免费的 .tech 域名等等。\n在选择了合适的域名之后我们在网站的后台便可以管理 DNS 记录，申请开通 SSL certificate 以进行网站的下一步搭建了。\n namechaeap 网站 \n初识 WordPress 云服务器创建好之后，便可以搭建 WordPress 开发环境了。由于编译安装需要输入大量的命令，如果是配置生产环境需要耗费大量的时间，同时对 Linux 小白不太友好，因此现在比较流行的是使用 LNMP/LAMP 等一键安装包进行环境搭建。\nLNMP 的全称为 Linux + Nginx + MySql + PHP，LAMP 的全称则为 Linux + Apache + MySql + PHP，由于 Nginx 使用资源少同时支持更多并发连接，对于静态内容比较多的网站支持性不错，因此我选择了 LNMP 作为开发环境，具体的安装文档可以在 LNMP.org 查阅。\n搭建好数据库设置完毕用户名、密码等基本信息后，我们便可以到网站的后台来管理自己的博客了，首先可以选择一个好看而简单的博客主题，在这里建议一般在官方后台以及 ThemeForest 等比较正规的主题网站上下载使用而避免第三方主题携带有恶意代码等。\nWordPress 网站的后期管理相对比较简单，许多维护问题在网站后台就可以解决，如果还有遇到的问题话，Google 以及 官方文档 中基本能告诉你答案。\n告别 WordPress 拥抱 GitHub Pages 由于 DigitalOcean 的垃圾服务以及对 WordPress 的厌倦，我希望能找到一个对 Markdown 支持更好、更能使人专注于创作而不是调整页面的平台，这让我回忆起了几年前创建的 GitHub Pages。\n由于不太需要动态内容，静态网站已经可以完美的满足我的需求，对于我来说，GitHub Pages 便是一个方便的实现方案。\n而既然选择了 GitHub Pages，相应的可以选择 Hugo、Hexo、jekyll 等静态网站生成器加以实现。由于对 Hugo 的一款主题十分钟情，我便毫不犹豫地选择了 Hugo，同时，Hugo 号称是世界上生成网站最快的 framwork 倒也是蛮不错的了。\n Hugo 的官方首页 \n安装 Hugo 在 Hugo 的安装中我开始遇到了一些麻烦，与 Mac 和 Linux 相比，Windows 端的 Hugo 安装显得略微繁琐，首先在 Hugo 的 Release 页面 根据相应的版本以及平台进行下载，64 位的 Windows 电脑即选择下图中某一个即可。\n Hugo 的发行页面 \n由于部分主题需要 Hugo 的 Extended 版本才可以正常使用，因此建议一步到位直接安装 Extended 版本的 Hugo，在将压缩包解压后一定不要忘记的是将 hugo.exe 所在的文件夹添加至系统的环境变量。\n若是以上步骤都正常完成，那么可以在输入 hugo version 命令后得到正常的版本号显示。\n 检查 Hugo 版本 \n接下来便可以正式的使用 Hugo 来创建你的网站。\n初始化网站 首先选择好一个合适的存储路径，接下来便可以通过 hugo new site XXX 的命令来初始化网站。\n 初始化网站 \n接下来便可以配置自己的博客主题了，我选择的是 MemE 主题，主要是看重它的简洁大方，同时字体渲染还蛮好看。主题的官方页面如下：https://github.com/reuixiy/hugo-theme-meme\n下一步便进行主题的安装：（假设 blog 是你创建的 site 的名称）\n~ $ cd blog ~/blog $ git init ~/blog $ git submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme 同时，你也可以尝试新建文章的操作：\n~/blog $ hugo new \u0026#34;posts/hello-world.md\u0026#34; ~/blog $ hugo new \u0026#34;about/_index.md\u0026#34; Hugo 提供了一种非常便捷的预览方式，输入命令\n~/blog $ hugo server -D 便可以在浏览器键入 http://localhost:1313/ 而实现网站的实时预览。\n自定义主题 Hugo 可以提供非常强大的主题自定义的能力，根据主题所提供的配置文件，我们可以不断丰富自己的网站的功能，也可以根据自己的喜好增添许多 CSS 样式来进行美化。\n以我所使用的主题 MemE 为例，可以选择开启 KaTeX、MathJax、Mermaid 等许多功能，同时对网站的几乎所有部分都可以更改或添加自定义元素：\n MemE 主题配置节选 \n使用 Github Pages 托管网站 随后便可以在 GitHub 上建立 Repo 来托管自己的网站代码了。\n 将 config.toml 中的 baseURL 更改为你自己的自定义域名。 在 GitHub 中创建一个名称为 username.github.io 的仓库（username 替换为你自己的用户名），同时其余选项均不勾选。 在你的 Hugo 网站目录下键入命令 hugo -v 生成网站的相应文件，存储在 public 目录下。 进入 public 目录下，并按照正常的 git 命令操作： $ cd public $ git init $ git remote add origin https://github.com/XXXX/XXXX.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master  如果 git 操作正常没有报错，那么这时你便可以在你的 GitHub 仓库中看到相应的文件了。  如果你需要使用自己的自定义域名来使你的 GiHub Pages 更为精致，那么你需要先到域名管理后台添加一条 CNAME 记录：\n CNAME 记录 \n进入仓库的 Settings 页面，找到 GitHub Pages 相应设置处：\n GitHub Pages 设置 \n按照 GitHub 的提示，将自定义域名填入 Custom Domain 处，并勾选 Enforce HTTPS，等待一段时间使 DNS 记录生效后，便可以成功的访问自己的域名来进入博客了。\n若是之后对文章进行了更新，便可以使用 git push 来进行同步：\n$ cd public $ git add . $ git status $ git commit -m \u0026#34;add posts\u0026#34; $ git push 最终我的博客现在大概长下面这样：\n 网站首页预览 \n文章的大致内容大概就这么多，祝愿大家都可以顺利的建立起自己的小站。\n","date":"2021-02-08T09:00:00+08:00","image":"https://blog.pkulkw.me/p/myblog/cover_huf457792323a2069bd48065af2e6d9388_96450_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.pkulkw.me/p/myblog/","title":"GitHub Pages + Hugo：我的博客搭建之路"}]